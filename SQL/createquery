-- Table: marine.fact_beachs

-- DROP TABLE IF EXISTS marine.fact_beachs;

CREATE TABLE IF NOT EXISTS marine.fact_beachs
(
    id bigint NOT NULL,
    beach_name character varying COLLATE pg_catalog."default" NOT NULL,
    lat numeric NOT NULL,
    lon numeric NOT NULL,
    orientacao character varying COLLATE pg_catalog."default",
    CONSTRAINT fact_beachs_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS marine.fact_beachs
    OWNER to postgres;

-- Table: marine.fact_marine_data

-- DROP TABLE IF EXISTS marine.fact_marine_data;

CREATE TABLE IF NOT EXISTS marine.fact_marine_data
(
    id bigint NOT NULL DEFAULT nextval('marine.fact_marine_data_id_seq'::regclass),
    extraction_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    timestamp_utc timestamp without time zone NOT NULL,
    "timestamp" timestamp without time zone NOT NULL,
    wave_height numeric(8,3),
    wave_direction numeric(6,2),
    wave_period numeric(6,2),
    wave_energy_kj_m2 numeric(10,2),
    wave_condition character varying(20) COLLATE pg_catalog."default",
    swell_wave_height numeric(8,3),
    swell_wave_direction numeric(6,2),
    swell_wave_period numeric(6,2),
    wind_wave_height numeric(8,3),
    wind_wave_direction numeric(6,2),
    wind_wave_period numeric(6,2),
    ocean_current_velocity numeric(6,3),
    ocean_current_direction numeric(6,2),
    ocean_current_kmh numeric(6,3),
    current_intensity character varying(20) COLLATE pg_catalog."default",
    sea_surface_temperature numeric(5,2),
    sea_temp_fahrenheit numeric(6,2),
    water_temp_class character varying(20) COLLATE pg_catalog."default",
    sea_level_height_msl numeric(7,3),
    sea_level_anomaly_m numeric(7,3),
    latitude numeric(10,7) NOT NULL,
    longitude numeric(10,7) NOT NULL,
    location_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    data_completeness_pct numeric(5,2),
    data_quality_score integer,
    is_validated boolean,
    is_anomaly boolean,
    api_source character varying(500) COLLATE pg_catalog."default",
    http_status_code integer,
    response_time_ms integer,
    extraction_timestamp timestamp without time zone,
    processing_start timestamp without time zone,
    processing_end timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    id_praia bigint,
    beach_name character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT fact_marine_data_pkey PRIMARY KEY (id),
    CONSTRAINT chk_completeness CHECK (data_completeness_pct >= 0::numeric AND data_completeness_pct <= 100::numeric),
    CONSTRAINT chk_quality_score CHECK (data_quality_score >= 0 AND data_quality_score <= 100),
    CONSTRAINT chk_wave_height CHECK (wave_height >= 0::numeric)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS marine.fact_marine_data
    OWNER to postgres;

COMMENT ON TABLE marine.fact_marine_data
    IS 'Tabela de factos com dados oceanográficos processados';

COMMENT ON COLUMN marine.fact_marine_data.wave_energy_kj_m2
    IS 'Energia das ondas calculada: E = 0.5 * ρ * g * H²';

COMMENT ON COLUMN marine.fact_marine_data.data_quality_score
    IS 'Score de qualidade (0-100) baseado em completude e consistência';

-- Table: log.log_table

-- DROP TABLE IF EXISTS log.log_table;

CREATE TABLE IF NOT EXISTS log.log_table
(
    id_job integer,
    channel_id character varying(255) COLLATE pg_catalog."default",
    jobname character varying(255) COLLATE pg_catalog."default",
    status character varying(15) COLLATE pg_catalog."default",
    lines_read bigint,
    lines_written bigint,
    lines_updated bigint,
    lines_input bigint,
    lines_output bigint,
    lines_rejected bigint,
    errors bigint,
    startdate timestamp without time zone,
    enddate timestamp without time zone,
    logdate timestamp without time zone,
    depdate timestamp without time zone,
    replaydate timestamp without time zone,
    log_field text COLLATE pg_catalog."default"
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS log.log_table
    OWNER to postgres;
-- Index: idx_log_table_1

-- DROP INDEX IF EXISTS log.idx_log_table_1;

CREATE INDEX IF NOT EXISTS idx_log_table_1
    ON log.log_table USING btree
    (id_job ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_log_table_2

-- DROP INDEX IF EXISTS log.idx_log_table_2;

CREATE INDEX IF NOT EXISTS idx_log_table_2
    ON log.log_table USING btree
    (errors ASC NULLS LAST, status COLLATE pg_catalog."default" ASC NULLS LAST, jobname COLLATE pg_catalog."default" ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
-- Index: idx_log_table_3

-- DROP INDEX IF EXISTS log.idx_log_table_3;

CREATE INDEX IF NOT EXISTS idx_log_table_3
    ON log.log_table USING btree
    (jobname COLLATE pg_catalog."default" ASC NULLS LAST, logdate ASC NULLS LAST)
    WITH (fillfactor=100, deduplicate_items=True)
    TABLESPACE pg_default;
